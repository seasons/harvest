{"version":3,"sources":["Matrix2D.ts"],"names":["DEG_TO_RAD","Math","identity","a","b","c","d","tx","ty","hasInitialState","change","a2","b2","c2","d2","translate","tx2","ty2","a1","b1","c1","d1","x","y","scaleX","scaleY","rotation","skewX","skewY","regX","regY","r","cos","sin","append"],"mappings":"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","sourcesContent":["/**\n * based on\n * https://github.com/CreateJS/EaselJS/blob/631cdffb85eff9413dab43b4676f059b4232d291/src/easeljs/geom/Matrix2D.js\n */\nconst DEG_TO_RAD = Math.PI / 180;\n\nexport const identity: [number, number, number, number, number, number] = [\n  1,\n  0,\n  0,\n  1,\n  0,\n  0,\n];\n\nlet a = 1;\nlet b = 0;\nlet c = 0;\nlet d = 1;\nlet tx = 0;\nlet ty = 0;\nlet hasInitialState = true;\n\n/**\n * Represents an affine transformation matrix, and provides tools for concatenating transforms.\n *\n * This matrix can be visualized as:\n *\n * \t[ a  c  tx\n * \t  b  d  ty\n * \t  0  0  1  ]\n *\n * Note the locations of b and c.\n **/\n\n/**\n * Reset current matrix to an identity matrix.\n * @method reset\n **/\nexport function reset() {\n  if (hasInitialState) {\n    return;\n  }\n  a = d = 1;\n  b = c = tx = ty = 0;\n  hasInitialState = true;\n}\n\n/**\n * Returns an array with current matrix values.\n * @method toArray\n * @return {Array} an array with current matrix values.\n **/\nexport function toArray(): [number, number, number, number, number, number] {\n  if (hasInitialState) {\n    return identity;\n  }\n  return [a, b, c, d, tx, ty];\n}\n\n/**\n * Appends the specified matrix properties to this matrix. All parameters are required.\n * This is the equivalent of multiplying `(this matrix) * (specified matrix)`.\n * @method append\n * @param {Number} a2\n * @param {Number} b2\n * @param {Number} c2\n * @param {Number} d2\n * @param {Number} tx2\n * @param {Number} ty2\n **/\nexport function append(\n  a2: number,\n  b2: number,\n  c2: number,\n  d2: number,\n  tx2: number,\n  ty2: number,\n) {\n  const change = a2 !== 1 || b2 !== 0 || c2 !== 0 || d2 !== 1;\n  const translate = tx2 !== 0 || ty2 !== 0;\n  if (!change && !translate) {\n    return;\n  }\n  if (hasInitialState) {\n    hasInitialState = false;\n    a = a2;\n    b = b2;\n    c = c2;\n    d = d2;\n    tx = tx2;\n    ty = ty2;\n    return;\n  }\n  const a1 = a;\n  const b1 = b;\n  const c1 = c;\n  const d1 = d;\n  if (change) {\n    a = a1 * a2 + c1 * b2;\n    b = b1 * a2 + d1 * b2;\n    c = a1 * c2 + c1 * d2;\n    d = b1 * c2 + d1 * d2;\n  }\n  if (translate) {\n    tx = a1 * tx2 + c1 * ty2 + tx;\n    ty = b1 * tx2 + d1 * ty2 + ty;\n  }\n}\n\n/**\n * Generates matrix properties from the specified display object transform properties, and appends them to this matrix.\n * For example, you can use this to generate a matrix representing the transformations of a display object:\n *\n * \treset();\n * \tappendTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation);\n * \tvar matrix = toArray()\n *\n * @method appendTransform\n * @param {Number} x\n * @param {Number} y\n * @param {Number} scaleX\n * @param {Number} scaleY\n * @param {Number} rotation\n * @param {Number} skewX\n * @param {Number} skewY\n * @param {Number} regX Optional.\n * @param {Number} regY Optional.\n **/\nexport function appendTransform(\n  x: number,\n  y: number,\n  scaleX: number,\n  scaleY: number,\n  rotation: number,\n  skewX: number,\n  skewY: number,\n  regX: number,\n  regY: number,\n) {\n  if (\n    x === 0 &&\n    y === 0 &&\n    scaleX === 1 &&\n    scaleY === 1 &&\n    rotation === 0 &&\n    skewX === 0 &&\n    skewY === 0 &&\n    regX === 0 &&\n    regY === 0\n  ) {\n    return;\n  }\n  let cos, sin;\n  if (rotation % 360) {\n    const r = rotation * DEG_TO_RAD;\n    cos = Math.cos(r);\n    sin = Math.sin(r);\n  } else {\n    cos = 1;\n    sin = 0;\n  }\n\n  const a2 = cos * scaleX;\n  const b2 = sin * scaleX;\n  const c2 = -sin * scaleY;\n  const d2 = cos * scaleY;\n\n  if (skewX || skewY) {\n    const b1 = Math.tan(skewY * DEG_TO_RAD);\n    const c1 = Math.tan(skewX * DEG_TO_RAD);\n    append(a2 + c1 * b2, b1 * a2 + b2, c2 + c1 * d2, b1 * c2 + d2, x, y);\n  } else {\n    append(a2, b2, c2, d2, x, y);\n  }\n\n  if (regX || regY) {\n    // append the registration offset:\n    tx -= regX * a + regY * c;\n    ty -= regX * b + regY * d;\n    hasInitialState = false;\n  }\n}\n"]}