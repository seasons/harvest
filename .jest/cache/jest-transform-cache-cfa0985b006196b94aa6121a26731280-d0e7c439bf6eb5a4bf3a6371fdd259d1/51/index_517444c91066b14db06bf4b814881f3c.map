{"version":3,"sources":["index.js"],"names":["responseHandler","response","exceptions","ok","json","AuthError","Auth","options","client","Client","clientId","Error","domain","parameters","query","redirectUri","required","toName","responseType","state","whitelist","url","client_id","federated","returnTo","payload","code","verifier","post","grant_type","then","username","password","realm","audience","scope","refreshToken","token","baseUrl","telemetry","claims","get","attributes","email","connection","metadata","Auth0Error"],"mappings":"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","sourcesContent":["import Client from '../networking';\nimport { apply } from '../utils/whitelist';\nimport { toCamelCase } from '../utils/camel';\nimport AuthError from './authError';\nimport Auth0Error from './auth0Error';\n\nfunction responseHandler(response, exceptions = {}) {\n  if (response.ok && response.json) {\n    return toCamelCase(response.json, exceptions);\n  }\n  throw new AuthError(response);\n}\n\n/**\n * Auth0 Auth API\n *\n * @export Auth\n * @see https://auth0.com/docs/api/authentication\n * @class Auth\n */\nexport default class Auth {\n  constructor(options = {}) {\n    this.client = new Client(options);\n    const { clientId } = options;\n    if (!clientId) {\n      throw new Error('Missing clientId in parameters');\n    }\n    this.domain = this.client.domain;\n    this.clientId = clientId;\n  }\n\n  /**\n   * Builds the full authorize endpoint url in the Authorization Server (AS) with given parameters.\n   *\n   * @param {Object} parameters parameters to send to `/authorize`\n   * @param {String} parameters.responseType type of the response to get from `/authorize`.\n   * @param {String} parameters.redirectUri where the AS will redirect back after success or failure.\n   * @param {String} parameters.state random string to prevent CSRF attacks.\n   * @returns {String} authorize url with specified parameters to redirect to for AuthZ/AuthN.\n   * @see https://auth0.com/docs/api/authentication#authorize-client\n   *\n   * @memberof Auth\n   */\n  authorizeUrl(parameters = {}) {\n    const query = apply(\n      {\n        parameters: {\n          redirectUri: { required: true, toName: 'redirect_uri' },\n          responseType: { required: true, toName: 'response_type' },\n          state: { required: true }\n        },\n        whitelist: false\n      },\n      parameters\n    );\n    return this.client.url(\n      '/authorize',\n      { ...query, client_id: this.clientId },\n      true\n    );\n  }\n\n  /**\n   * Builds the full logout endpoint url in the Authorization Server (AS) with given parameters.\n   *\n   * @param {Object} parameters parameters to send to `/v2/logout`\n   * @param {Boolean} [parameters.federated] if the logout should include removing session for federated IdP.\n   * @param {String} [parameters.clientId] client identifier of the one requesting the logout\n   * @param {String} [parameters.returnTo] url where the user is redirected to after logout. It must be declared in you Auth0 Dashboard\n   * @returns {String} logout url with specified parameters\n   * @see https://auth0.com/docs/api/authentication#logout\n   *\n   * @memberof Auth\n   */\n  logoutUrl(parameters = {}) {\n    const query = apply(\n      {\n        parameters: {\n          federated: { required: false },\n          clientId: { required: false, toName: 'client_id' },\n          returnTo: { required: false }\n        }\n      },\n      parameters\n    );\n    return this.client.url('/v2/logout', { ...query }, true);\n  }\n\n  /**\n   * Exchanges a code obtained via `/authorize` (w/PKCE) for the user's tokens\n   *\n   * @param {Object} parameters parameters used to obtain tokens from a code\n   * @param {String} parameters.code code returned by `/authorize`.\n   * @param {String} parameters.redirectUri original redirectUri used when calling `/authorize`.\n   * @param {String} parameters.verifier value used to generate the code challenge sent to `/authorize`.\n   * @returns {Promise}\n   * @see https://auth0.com/docs/api-auth/grant/authorization-code-pkce\n   *\n   * @memberof Auth\n   */\n  exchange(parameters = {}) {\n    const payload = apply(\n      {\n        parameters: {\n          code: { required: true },\n          verifier: { required: true, toName: 'code_verifier' },\n          redirectUri: { required: true, toName: 'redirect_uri' }\n        }\n      },\n      parameters\n    );\n    return this.client\n      .post('/oauth/token', {\n        ...payload,\n        client_id: this.clientId,\n        grant_type: 'authorization_code'\n      })\n      .then(responseHandler);\n  }\n\n  /**\n   * Performs Auth with user credentials using the Password Realm Grant\n   *\n   * @param {Object} parameters password realm parameters\n   * @param {String} parameters.username user's username or email\n   * @param {String} parameters.password user's password\n   * @param {String} parameters.realm name of the Realm where to Auth (or connection name)\n   * @param {String} [parameters.audience] identifier of Resource Server (RS) to be included as audience (aud claim) of the issued access token\n   * @param {String} [parameters.scope] scopes requested for the issued tokens. e.g. `openid profile`\n   * @returns {Promise}\n   * @see https://auth0.com/docs/api-auth/grant/password#realm-support\n   *\n   * @memberof Auth\n   */\n  passwordRealm(parameters = {}) {\n    const payload = apply(\n      {\n        parameters: {\n          username: { required: true },\n          password: { required: true },\n          realm: { required: true },\n          audience: { required: false },\n          scope: { required: false }\n        }\n      },\n      parameters\n    );\n    return this.client\n      .post('/oauth/token', {\n        ...payload,\n        client_id: this.clientId,\n        grant_type: 'http://auth0.com/oauth/grant-type/password-realm'\n      })\n      .then(responseHandler);\n  }\n\n  /**\n   * Obtain new tokens using the Refresh Token obtained during Auth (requesting `offline_access` scope)\n   *\n   * @param {Object} parameters refresh token parameters\n   * @param {String} parameters.refreshToken user's issued refresh token\n   * @param {String} [parameters.scope] scopes requested for the issued tokens. e.g. `openid profile`\n   * @returns {Promise}\n   * @see https://auth0.com/docs/tokens/refresh-token/current#use-a-refresh-token\n   *\n   * @memberof Auth\n   */\n  refreshToken(parameters = {}) {\n    const payload = apply(\n      {\n        parameters: {\n          refreshToken: { required: true, toName: 'refresh_token' },\n          scope: { required: false }\n        }\n      },\n      parameters\n    );\n    return this.client\n      .post('/oauth/token', {\n        ...payload,\n        client_id: this.clientId,\n        grant_type: 'refresh_token'\n      })\n      .then(responseHandler);\n  }\n\n  /**\n   * Revoke an issued refresh token\n   *\n   * @param {Object} parameters revoke token parameters\n   * @param {String} parameters.refreshToken user's issued refresh token\n   * @returns {Promise}\n   *\n   * @memberof Auth\n   */\n  revoke(parameters = {}) {\n    const payload = apply(\n      {\n        parameters: {\n          refreshToken: { required: true, toName: 'token' }\n        }\n      },\n      parameters\n    );\n    return this.client\n      .post('/oauth/revoke', {\n        ...payload,\n        client_id: this.clientId\n      })\n      .then(response => {\n        if (response.ok) {\n          return {};\n        }\n        throw new AuthError(response);\n      });\n  }\n\n  /**\n   * Return user information using an access token\n   *\n   * @param {Object} parameters user info parameters\n   * @param {String} parameters.token user's access token\n   * @returns {Promise}\n   *\n   * @memberof Auth\n   */\n  userInfo(parameters = {}) {\n    const payload = apply(\n      {\n        parameters: {\n          token: { required: true }\n        }\n      },\n      parameters\n    );\n    const { baseUrl, telemetry } = this.client;\n    const client = new Client({ baseUrl, telemetry, token: payload.token });\n    const claims = [\n      'sub',\n      'name',\n      'given_name',\n      'family_name',\n      'middle_name',\n      'nickname',\n      'preferred_username',\n      'profile',\n      'picture',\n      'website',\n      'email',\n      'email_verified',\n      'gender',\n      'birthdate',\n      'zoneinfo',\n      'locale',\n      'phone_number',\n      'phone_number_verified',\n      'address',\n      'updated_at'\n    ];\n    return client\n      .get('/userinfo')\n      .then(response =>\n        responseHandler(response, { attributes: claims, whitelist: true })\n      );\n  }\n\n  /**\n   * Request an email with instructions to change password of a user\n   *\n   * @param {Object} parameters reset password parameters\n   * @param {String} parameters.email user's email\n   * @param {String} parameters.connection name of the connection of the user\n   * @returns {Promise}\n   *\n   * @memberof Auth\n   */\n  resetPassword(parameters = {}) {\n    const payload = apply(\n      {\n        parameters: {\n          email: { required: true },\n          connection: { required: true }\n        }\n      },\n      parameters\n    );\n    return this.client\n      .post('/dbconnections/change_password', {\n        ...payload,\n        client_id: this.clientId\n      })\n      .then(response => {\n        if (response.ok) {\n          return {};\n        }\n        throw new AuthError(response);\n      });\n  }\n\n  /**\n   *\n   *\n   * @param {Object} parameters create user parameters\n   * @param {String} parameters.email user's email\n   * @param {String} [parameters.username] user's username\n   * @param {String} parameters.password user's password\n   * @param {String} parameters.connection name of the database connection where to create the user\n   * @param {String} [parameters.metadata] additional user information that will be stored in `user_metadata`\n   * @returns {Promise}\n   *\n   * @memberof Auth\n   */\n  createUser(parameters = {}) {\n    const payload = apply(\n      {\n        parameters: {\n          email: { required: true },\n          password: { required: true },\n          connection: { required: true },\n          username: { required: false },\n          metadata: { required: false, toName: 'user_metadata' }\n        }\n      },\n      parameters\n    );\n\n    return this.client\n      .post('/dbconnections/signup', {\n        ...payload,\n        client_id: this.clientId\n      })\n      .then(response => {\n        if (response.ok && response.json) {\n          return toCamelCase(response.json);\n        }\n        throw new Auth0Error(response);\n      });\n  }\n}\n"]}